// src/pages/ChatLayout.tsx
import {
  useEffect, useState, useRef, useCallback, ChangeEvent, useLayoutEffect
} from "react";
import { useNavigate } from "react-router-dom";
import dayjs from "dayjs";
import {
  Box, Drawer, Toolbar, List, ListItemButton, ListItemText, Divider,
  AppBar, Typography, Button, TextField, Switch, FormControlLabel,
  ListSubheader, Dialog, DialogTitle, DialogContent, DialogActions,
  LinearProgress, IconButton, Paper, useTheme,
} from "@mui/material";
import { ThumbUp, ThumbDown, Mic } from "@mui/icons-material";
import { Edit, Delete } from "@mui/icons-material";
import ToggleButton from "@mui/material/ToggleButton";
import ToggleButtonGroup from "@mui/material/ToggleButtonGroup";
import ChatOutlinedIcon from "@mui/icons-material/ChatOutlined";
import ArticleOutlinedIcon from "@mui/icons-material/ArticleOutlined";
import { VariableSizeList, ListChildComponentProps } from "react-window";
import useResizeObserver from "../hooks/useResizeObserver";
import AutoSizer from "react-virtualized-auto-sizer";
import type { Size } from "react-virtualized-auto-sizer";
import { fetchWithAuth } from "../utils/api";
import ProfilingDialog from "../components/ProfilingDialog";
import { Dialog as MuiDialog, /* ‚Ä¶ */ } from "@mui/material";

/* ---------- types ---------- */
interface FeedbackInfo {
  feedback_id?: number;
  feedback_score?: number;
  feedback_label?: string;
  details?: any;
}
interface RecommendCard {
  card_id: string;
  type: string;
  title: string;
  subtitle?: string;
  link?: string;
  reason?: string;
  score?: number;
  feedback?: FeedbackInfo | null;
}
interface Message {
  message_id: number;
  role: string;
  content: string;
  created_at: string;
  cards?: RecommendCard[];
  images?: ImageThumb[];
  feedback?: FeedbackInfo | null;
}
interface AgendaEvent {
  id: string;
  summary: string;
  start: { dateTime?: string; date?: string };
}
interface ImageThumb {
  image_id: number;
  thumb: string;          // ‚Üê ÏÑúÎ≤Ñ ÌÇ§ Í∑∏ÎåÄÎ°ú
}

/* =================================================================== */
export default function ChatLayout() {
  const navigate = useNavigate();
  const theme = useTheme();

  /* ---------- state ---------- */
  const [userName, setUserName]           = useState("");
  const [profileExists, setProfileExists] = useState(false);
  const [conversations, setConversations] = useState<any[]>([]);
  const [selectedConversation, setSelectedConversation] = useState<number|null>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputMode, setInputMode] = useState<"chat" | "summary">("chat");

  const [question,    setQuestion]    = useState("");
  const [searchMode,  setSearchMode]  = useState(false);
  const [uploadFile,  setUploadFile]  = useState<File|null>(null);
  const [isLoading,   setIsLoading]   = useState(false);
  const [isRecording, setIsRecording] = useState(false);
  const [recordLeft,  setRecordLeft]  = useState(5);   // ‚òÖ NEW ‚Äì ÎÇ®ÏùÄ Ï¥à
  const recordTimer = useRef<NodeJS.Timeout|null>(null); // ‚òÖ NEW

  const [agenda,      setAgenda]      = useState<AgendaEvent[]>([]);
  const [gcConnected, setGcConnected] = useState(false);

  /* ----- quick-event dialog ----- */
  const [openQuick,   setOpenQuick]   = useState(false);
  const [quickTitle,  setQuickTitle]  = useState("");
  const [quickDate,   setQuickDate]   = useState(dayjs().format("YYYY-MM-DD"));

  const [openProfileDlg, setOpenProfileDlg] = useState(false);
  const [editCid,   setEditCid]   = useState<number|null>(null);      // ‚òÖ NEW
  const [editTitle, setEditTitle] = useState("");                     // ‚òÖ NEW
  const [fullImgUrl, setFullImgUrl] = useState<string|null>(null);

  /* ---------- virtualization refs ---------- */
  const listRef = useRef<VariableSizeList>(null);
  const sizeMap = useRef<{ [k:number]:number }>({});
  const getSize = (idx:number)=> sizeMap.current[idx] ?? 120;     // fallback height
  const setSize = (idx:number,h:number)=>{
    if (sizeMap.current[idx] !== h) {
      sizeMap.current = { ...sizeMap.current, [idx]: h };
      listRef.current?.resetAfterIndex(idx);
    }
  };

  /* =================================================================== */
  /*   1. Ï≤´ Î°úÎî©   */
  useEffect(() => {
    const token = localStorage.getItem("token");
    if (!token) { navigate("/login"); return; }

    /* ÌîÑÎ°úÌïÑ */
    fetchWithAuth("/profile")
      .then(()=> setProfileExists(true))
      .catch(err=>{
        if (err.status===404) { setProfileExists(false); setOpenProfileDlg(true); }
      });

    /* ÏÇ¨Ïö©Ïûê ¬∑ ÎåÄÌôî Î™©Î°ù ¬∑ ÏùºÏ†ï 3Ïùº */
    fetchWithAuth("/auth/me").then(d=> setUserName(d.username));
    fetchWithAuth("/chat/conversations").then(setConversations);

    const end = new Date(Date.now()+3*86400e3).toISOString();
    fetchWithAuth(`/events?end=${end}`).then(setAgenda);

    /* GCal Ïó∞Í≤∞ Ïó¨Î∂Ä */
    fetchWithAuth("/gcal/status").then(d=> setGcConnected(d.connected));
  }, []);

  /*   2. ÎåÄÌôî ÏÑ†ÌÉù ‚Üí Î©îÏãúÏßÄ Î°úÎî©   */
  useEffect(() => {
    if (!selectedConversation) { setMessages([]); return; }
    loadConversation(selectedConversation);
  }, [selectedConversation]);

  useEffect(() => {
    if (!messages.length || !listRef.current) return;
    // ÎßàÏßÄÎßâ ÌñâÏúºÎ°ú Ïä§ÌÅ¨Î°§ ‚Äì 'end' Îäî ÏÇ¥Ïßù Ïó¨Ïú†Î•º Îë¨ ÍπîÎÅî
    listRef.current.scrollToItem(messages.length - 1, "end");
  }, [messages.length]);   // ‚Üê Î©îÏãúÏßÄ Í∞úÏàò Î≥ÄÌï† ÎïåÎßàÎã§ Ïã§Ìñâ

  /* ---------- helpers ---------- */
  const loadConversation = async (cid:number)=>{
    const d = await fetchWithAuth(`/chat/conversations/${cid}`);
    const sorted = [...d.messages].sort(
      (a,b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
    );
    setMessages(sorted);
    sizeMap.current = {};
    listRef.current?.resetAfterIndex(0);
  };
  const loadConversationList = async ()=>{
    setConversations(await fetchWithAuth("/chat/conversations"));
  };
  const reloadAgenda = async ()=>{
    const end = new Date(Date.now()+3*86400e3).toISOString();
    setAgenda(await fetchWithAuth(`/events?end=${end}`));
  };
  const refreshGcalStatus = async ()=>{
    const { connected } = await fetchWithAuth("/gcal/status");
    setGcConnected(connected);
  };

  /* ---------- Google Calendar Ïó∞Í≤∞/Ìï¥Ï†ú ---------- */
  const toggleGoogle = async ()=>{
    if (!gcConnected) {
      const { auth_url } = await fetchWithAuth("/gcal/authorize");
      const popup = window.open(auth_url,"_blank","width=500,height=650");
      const handler = (e:MessageEvent)=>{
        if(e.data==="gcal_success"){ popup?.close(); window.removeEventListener("message",handler); refreshGcalStatus(); reloadAgenda(); }
      };
      window.addEventListener("message",handler);
    } else {
      setGcConnected(false); setAgenda([]);
      await fetchWithAuth("/gcal/disconnect",{method:"DELETE"}); refreshGcalStatus();
    }
  };

  /* ---------- ÏÉàÎ°úÏö¥ ÎåÄÌôî ---------- */
  const newConversation = ()=>{
    setSelectedConversation(null);
    setMessages([]);
    sizeMap.current = {};
  };

  const renameConversation = async (cid: number, title: string) => {
    await fetchWithAuth(`/chat/conversations/${cid}`, {
      method: "PATCH",
      body: JSON.stringify({ title }),
      raw: true,                 // üîë 204(ÎòêÎäî body ÏóÜÏùå) ÎåÄÎπÑ
    });
    await loadConversationList();
    if (selectedConversation === cid) loadConversation(cid); // Ï†úÎ™© Ï¶âÏãú Î∞òÏòÅ
  };
  
  const deleteConversation = async (cid: number) => {
    if (!window.confirm("ÏÑ†ÌÉùÌïú ÎåÄÌôîÎ•º Ï†ïÎßê ÏÇ≠Ï†úÌï†ÍπåÏöî?")) return;
  
    await fetchWithAuth(`/chat/conversations/${cid}`, {
      method: "DELETE",
      raw: true,                 // üîë 204 ÎåÄÎπÑ
    });
  
    // Î™©Î°ù ÏÉàÎ°úÍ≥†Ïπ®
    await loadConversationList();
  
    // Î∞©Í∏à Î≥¥Í≥† ÏûàÎçò ÎåÄÌôîÎ•º ÏßÄÏõ†Îã§Î©¥ ‚Üí Ïò§Î•∏Ï™Ω Ìå®ÎÑêÎèÑ Ï¥àÍ∏∞Ìôî
    if (selectedConversation === cid) {
      setSelectedConversation(null);
      setMessages([]);
      sizeMap.current = {};                 // üîë react-window ÎÜíÏù¥ Ï∫êÏãú Î¶¨ÏÖã
      listRef.current?.resetAfterIndex(0);
    }
  };

  /* =================================================================== */
  /*   3. send() ‚Äì Í∏∞Ï°¥ REST ÌùêÎ¶Ñ Ïú†ÏßÄ   */
  const send = async ()=>{
    if (!question.trim() || isLoading) return;
    setIsLoading(true);

    const endpoint = searchMode ? "/search" : "/chat";
    const payload  = {
      conversation_id: selectedConversation,
      question,
      query: question,
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    };

    try{
      const data = await fetchWithAuth(endpoint,{ method:"POST", body:JSON.stringify(payload) });

      /* ÎåÄÌôî ¬∑ Î©îÏãúÏßÄ ¬∑ ÏùºÏ†ï Îã§Ïãú ÏùΩÍ∏∞ */
      if (data.conversation_id) {
        setSelectedConversation(data.conversation_id);
        await loadConversation(data.conversation_id);
        await loadConversationList();
        await reloadAgenda();
      }
    } finally {
      setIsLoading(false);
      setQuestion("");
    }
  };

  /* ---------- ÏùåÏÑ± ÎÖπÏùå + Ï†ÑÏÜ° ---------- */
  const recordAndSend = async () => {
    if (isRecording || isLoading) return;
  
    /* ‚ë† ÎÖπÏùå ÏãúÏûë --------------------------------------------------- */
    setIsRecording(true);
    setRecordLeft(5);
    recordTimer.current && clearInterval(recordTimer.current);
    recordTimer.current = setInterval(() => {
      setRecordLeft((sec) => (sec > 1 ? sec - 1 : sec));
    }, 1_000);
  
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const media  = new MediaRecorder(stream, { mimeType: "audio/webm" });
    const chunks: BlobPart[] = [];
    media.ondataavailable = (e) => e.data.size && chunks.push(e.data);
    media.start();
  
    /* ‚ë° 5Ï¥à ÌõÑ ÏûêÎèô Ï¢ÖÎ£å ------------------------------------------- */
    await new Promise<void>((res) => setTimeout(res, 5_000));
    media.stop();
    await new Promise<void>((res) => (media.onstop = () => res()));
    stream.getTracks().forEach((t) => t.stop());
  
    /* ‚ë¢ ÌåùÏóÖ Îã´Í∏∞ & ÌÉÄÏù¥Î®∏ Ìï¥Ï†ú ------------------------------------- */
    recordTimer.current && clearInterval(recordTimer.current);
    setIsRecording(false);
  
    /* ‚ë£ Î∞±ÏóîÎìú Ï†ÑÏÜ°(Ïù¥Ï†Ñ ÏΩîÎìú Í∑∏ÎåÄÎ°ú) ------------------------------- */
    const blob = new Blob(chunks, { type: "audio/webm" });
    const fd   = new FormData();
    if (selectedConversation) fd.append("conversation_id", String(selectedConversation));
    fd.append("timezone", Intl.DateTimeFormat().resolvedOptions().timeZone);
    fd.append("audio", blob, "speech.webm");
  
    setIsLoading(true);
    try {
      const data = await fetchWithAuth("/speech/chat", { method: "POST", body: fd });
      if (data.conversation_id) {
        setSelectedConversation(data.conversation_id);
        await loadConversation(data.conversation_id);
        await loadConversationList();
        await reloadAgenda();
      }
    } finally {
      setIsLoading(false);
    }
  };

  /* ---------- ÌååÏùº ÏöîÏïΩ ---------- */
  const summarize = async ()=>{
    if(!uploadFile) return;
    setIsLoading(true);

    const fd = new FormData();
    fd.append("file",uploadFile);
    if(selectedConversation) fd.append("conversation_id",String(selectedConversation));

    const data = await fetchWithAuth("/summarize",{method:"POST",body:fd});
    if(data.conversation_id) setSelectedConversation(data.conversation_id);

    let summaryText: string;

    if (typeof data.summary === "string" && data.summary.startsWith('"')) {
      // Îî∞Ïò¥ÌëúÎ°ú ÎëòÎü¨Ïã∏Ïù∏ ÌòïÌÉúÎ©¥ JSON.parse ÏãúÎèÑ
      try {
        summaryText = JSON.parse(data.summary)
                          .replace(/\\n/g, "\n")      // \n ‚Üí Ï§ÑÎ∞îÍøà
                          .replace(/\\"/g, "\"");      // \" ‚Üí "
      } catch {
        summaryText = data.summary;                   // Ïã§Ìå®ÌïòÎ©¥ ÏõêÎ≥∏ Ïú†ÏßÄ
      }
    } else {
      summaryText = String(data.summary);
    }

    const now = Date.now();
    setMessages(p=>[
      ...p,
      {message_id:now,role:"user",content:`[ÌååÏùºÏöîÏïΩ] ${uploadFile.name}`,created_at:new Date().toISOString()},
      {message_id:now+1,role:"assistant",content:summaryText,created_at:new Date().toISOString()},
    ]);
    setUploadFile(null);
    setIsLoading(false);
  };

  /* ---------- ÌîºÎìúÎ∞± ---------- */
  const sendCardFeedback = async (card_id:string,label:string)=>{
    await fetchWithAuth("/feedback",{method:"POST",body:JSON.stringify({
      category:"recommend",reference_id:`card_id=${card_id}`,feedback_label:label
    })});
    if(selectedConversation) loadConversation(selectedConversation);
  };
  const sendMessageFeedback = async (mid:number,label:string)=>{
    await fetchWithAuth("/feedback",{method:"POST",body:JSON.stringify({
      category:"chat",reference_id:`message_${mid}`,feedback_label:label
    })});
    if(selectedConversation) loadConversation(selectedConversation);
  };
  const iconColor = (current:string|undefined,target:string)=>(
    current===target ? (target==="like"?"success":"error") : "default"
  );

  /* =================================================================== */
  /*   4. react-window Row renderer   */
  const Row = useCallback(
    ({ index, style }: ListChildComponentProps) => {
      const m = messages[index];
      const isAssistant = m.role === "assistant";
  
      const rowStyle: React.CSSProperties = { ...style, width: "100%" };
      const measuredRef = useResizeObserver(rect => {
        const h = rect.height + 8;
        if (sizeMap.current[index] !== h) {
          sizeMap.current = { ...sizeMap.current, [index]: h };
          listRef.current?.resetAfterIndex(index);

          if (index === messages.length - 1) {
            listRef.current?.scrollToItem(index, "end");
          }
        }
      });
  
      return (
        <div style={rowStyle}>
          <Box ref={measuredRef} sx={{ px:1, py:0.5 }}>
            <Typography variant="subtitle2" color="text.secondary">
              {m.role}:
            </Typography>

          {m.cards?.length ? (
            <Box sx={{ mt:1, pl:2, borderLeft:`4px solid ${theme.palette.divider}` }}>
              {m.cards.map(card=>(
                <Box key={card.card_id} sx={{ mb:1 }}>
                  <Typography variant="subtitle1" fontWeight="bold">{card.title}</Typography>
                  {card.subtitle && <Typography variant="body2" color="text.secondary">{card.subtitle}</Typography>}
                  {card.link && (
                    <Button size="small" variant="outlined" onClick={()=>window.open(card.link,"_blank")}>ÏûêÏÑ∏Ìûà</Button>
                  )}
                  {card.reason && (
                    <Typography variant="caption" sx={{ display:"block", mt:0.5 }}>ÏÇ¨Ïú†: {card.reason}</Typography>
                  )}
                  <Box sx={{ display:"flex", gap:0.5, mt:0.5 }}>
                    <IconButton
                      size="small"
                      color={iconColor(card.feedback?.feedback_label,"like")}
                      onClick={()=>sendCardFeedback(card.card_id,"like")}
                    ><ThumbUp fontSize="inherit" /></IconButton>
                    <IconButton
                      size="small"
                      color={iconColor(card.feedback?.feedback_label,"dislike")}
                      onClick={()=>sendCardFeedback(card.card_id,"dislike")}
                    ><ThumbDown fontSize="inherit" /></IconButton>
                  </Box>
                </Box>
              ))}
            </Box>
          ) : (
            <Typography
              whiteSpace="pre-line"
              sx={{ wordBreak:"break-word" }}
            >
              {m.content}
            </Typography>
          )}

          {m.images?.length ? (
            <Box sx={{ mt: 1, display:"flex", gap:1, flexWrap:"wrap" }}>
              {m.images.map(img => (
                <Box key={img.image_id}>
                  <img
                    src={`data:image/webp;base64,${img.thumb}`}
                    width={128}
                    height={128}
                    style={{
                      objectFit: "cover",
                      borderRadius: 6,
                      cursor: "pointer",
                    }}
                    onLoad={(e) => {
                      /* react-window ÎÜíÏù¥ Ïû¨Í≥ÑÏÇ∞ */
                      const h = Math.max(e.currentTarget.height, 128) + 40;
                      setSize(index, h);
                    }}
                    onClick={async ()=>{
                      // 1) Ïù∏Ï¶ù ÌÜ†ÌÅ∞ Ìè¨Ìï® GET
                      const res = await fetchWithAuth(`/chat/images/${img.image_id}`, {
                        raw: true                           // fetchWithAuth ÎûòÌçºÏóê body ÏóÜÎäî raw ÏùëÎãµ ÏòµÏÖò
                      });
                    
                      // res Îäî Blob (image/webp) ‚Äî URL.createObjectURL Î°ú Î≥ÄÌôò
                      const blob = await res.blob();
                      setFullImgUrl(URL.createObjectURL(blob));
                    }}
                  />
                </Box>
              ))}
            </Box>
          ) : null}

          {isAssistant && (
            <Box sx={{ display:"flex", gap:0.5, mt:1 }}>
              <IconButton size="small" color={iconColor(m.feedback?.feedback_label,"like")}   onClick={()=>sendMessageFeedback(m.message_id,"like")}  ><ThumbUp   fontSize="inherit"/></IconButton>
              <IconButton size="small" color={iconColor(m.feedback?.feedback_label,"dislike")}onClick={()=>sendMessageFeedback(m.message_id,"dislike")}><ThumbDown fontSize="inherit"/></IconButton>
            </Box>
          )}
        </Box>
      </div>
    );
  },[messages]);

  /* =================================================================== */
  /*   5. render   */
  return (
    <Box sx={{ display:"flex", height:"100%", overflow:"hidden" }}>
      {/* ---------------- Drawer ---------------- */}
      <Drawer variant="permanent" sx={{ width:240,
        [`& .MuiDrawer-paper`]:{ width:240, top:64, boxSizing:"border-box" } }}>
        <Toolbar />
        <List>
          <ListItemButton sx={{ bgcolor:"action.hover" }} onClick={newConversation}>
            <ListItemText primary="ÏÉàÎ°úÏö¥ ÎåÄÌôî ÏãúÏûë"/>
          </ListItemButton>
          <Divider />
          {conversations.map(c=>(
            <ListItemButton key={c.conversation_id}
              selected={c.conversation_id===selectedConversation}
              onClick={()=>setSelectedConversation(c.conversation_id)}
              sx={{ pr:8 /* ÏïÑÏù¥ÏΩò Í≥µÍ∞Ñ ÌôïÎ≥¥ */ }}                          // ‚òÖ NEW
            >
              <ListItemText
                primary={c.title||`Conv ${c.conversation_id}`}
                primaryTypographyProps={{ noWrap:true }}
              />
              {/* Ïò§Î•∏Ï™Ω Ìé∏Ïßë¬∑ÏÇ≠Ï†ú ÏïÑÏù¥ÏΩò (hover ÏãúÎßå Î∂àÌà¨Î™Ö) */}
              <Box
                sx={{
                  position:"absolute", right:8, display:"flex", gap:0.5,
                  opacity:0.0, transition:"opacity .2s",
                  "&:hover":{ opacity:1.0 }
                }}
              >
                <IconButton
                  size="small"
                  onClick={(e)=>{ e.stopPropagation(); setEditCid(c.conversation_id); setEditTitle(c.title||""); }}
                ><Edit fontSize="inherit"/></IconButton>
                <IconButton
                  size="small"
                  onClick={(e)=>{ e.stopPropagation(); deleteConversation(c.conversation_id); }}
                ><Delete fontSize="inherit"/></IconButton>
              </Box>
            </ListItemButton>
          ))}
        </List>
        <Divider />
        <List subheader={<ListSubheader>Îã§Í∞ÄÏò§Îäî ÏùºÏ†ï</ListSubheader>}>
          {agenda.map(ev=>(
            <ListItemButton key={ev.id} onClick={()=>navigate(`/calendar?e=${ev.id}`)}>
              <ListItemText
                primary={ev.summary}
                secondary={dayjs(ev.start.dateTime||ev.start.date).format("DD HH:mm")}
              />
            </ListItemButton>
          ))}
          {!agenda.length && <ListItemText sx={{ p:2 }} secondary="ÏòàÏ†ïÎêú ÏùºÏ†ï ÏóÜÏùå"/>}

          {/* ‚îÄ‚îÄ‚îÄ ÏÉàÎ°ú Ï∂îÍ∞ÄÎêú ‚ÄúÎπ†Î•∏ ÏùºÏ†ï‚Äù Î≤ÑÌäº ‚îÄ‚îÄ‚îÄ */}
          <ListItemButton
            sx={{ mt:1, bgcolor:"action.hover" }}
            onClick={()=>setOpenQuick(true)}
          >
            <ListItemText primary="Ôºã Îπ†Î•∏ ÏùºÏ†ï" />
          </ListItemButton>
        </List>
      </Drawer>

      {/* ---------------- Main ---------------- */}
      <Box sx={{ flex:1, display:"flex", flexDirection:"column", minWidth:0, 
        minHeight: 0, p:2, gap: 1
       }}>
        {/* AppBar */}
        <AppBar position="relative" color="default" sx={{ zIndex:1200 }}>
          <Toolbar>
            <Typography sx={{ flexGrow:1 }}>ÎåÄÌôî</Typography>
            <Button variant="outlined" onClick={toggleGoogle} sx={{ mr:2 }}>
              {gcConnected ? "Google Ïó∞Í≤∞ Ìï¥Ï†ú" : "Google Ïó∞Í≤∞"}
            </Button>
            <Typography sx={{ mr:2 }}>{userName}</Typography>
            {profileExists && <Button variant="outlined" sx={{ mr:2 }} onClick={()=>{ setProfileExists(false); setOpenProfileDlg(true); }}>ÌîÑÎ°úÌïÑ Ìé∏Ïßë</Button>}
            <Button onClick={()=>{ localStorage.removeItem("token"); navigate("/login"); }}>Logout</Button>
          </Toolbar>
        </AppBar>

        {isLoading && <LinearProgress />}

        {/* Î©îÏãúÏßÄ ÏòÅÏó≠ */}
        <Paper
          sx={{
            flex: "1 1 auto",   // column ÎÇ¥Î∂ÄÏóêÏÑú ‚ÄòÍ∞ÄÎ≥Ä(ÎÇ®Îäî) ÎÜíÏù¥‚Äô ÏòÅÏó≠
            minHeight: 0,       // Ï§ëÏöî: react-window Í∞Ä Ï†ïÌôïÌûà height Í≥ÑÏÇ∞
            overflow: "hidden",
          }}
        >
          {messages.length===0 ? (
            <Box sx={{ p:2 }}><Typography color="text.secondary">ÎåÄÌôîÍ∞Ä ÏóÜÏäµÎãàÎã§.</Typography></Box>
          ) : (
            <AutoSizer>
              {({ height, width }: Size) => (
                <VariableSizeList
                  ref={listRef}
                  height={height}
                  width={width}
                  itemCount={messages.length}
                  itemSize={getSize}
                  overscanCount={4}
                  itemKey={(index: number) => messages[index].message_id}
                >
                  {Row}
                </VariableSizeList>
              )}
            </AutoSizer>
          )}
        </Paper>

        {/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ÏûÖÎ†•/ÏöîÏïΩ Ïª®Ìä∏Î°§ (1 Ï§Ñ) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}
        <Box
          sx={{
            flex: "0 0 auto",   // Í≥†Ï†ï ÎÜíÏù¥
            display: "flex",
            gap: 1,
            alignItems: "center",
          }}
        >

        {/* Î™®Îìú ÏïÑÏù¥ÏΩò ÌÜ†Í∏Ä */}
        <ToggleButtonGroup
          color="primary"
          value={inputMode}
          exclusive
          onChange={(_, v) => v && setInputMode(v)}
          size="small"
        >
          <ToggleButton value="chat"   sx={{ px:1 }} aria-label="Ï±ÑÌåÖ">
            <ChatOutlinedIcon fontSize="small" />
          </ToggleButton>
          <ToggleButton value="summary" sx={{ px:1 }} aria-label="Î¨∏ÏÑú ÏöîÏïΩ">
            <ArticleOutlinedIcon fontSize="small" />
          </ToggleButton>
        </ToggleButtonGroup>

        {/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ chat Î™®Îìú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}
        {inputMode === "chat" && (
          <>
            <FormControlLabel
              sx={{ mr: 1,
                '.MuiFormControlLabel-label': {
                  fontSize: 12,          // Îçî ÏûëÏùÄ Í∏ÄÍº¥
                  width: 32,             // ÏÖÄ ÎÑàÎπÑ ÌôïÎ≥¥ (ÌïÑÏöîÌïòÎ©¥ 36¬∑40 ÏúºÎ°ú Ï°∞Ï†à)
                  textAlign: 'center',
                  letterSpacing: '0.03em'
                }
               }}
              control={
                <Switch
                  size="small"
                  checked={searchMode}
                  onChange={e => setSearchMode(e.target.checked)}
                />
              }
              label="Í≤ÄÏÉâ"
            />

            <TextField
              fullWidth
              size="small"
              label="Î©îÏãúÏßÄ ÏûÖÎ†•"
              value={question}
              onChange={e => setQuestion(e.target.value)}
              onKeyDown={e => { if (e.key === "Enter") send(); }}
            />

            <Button
              variant="contained"
              onClick={send}
              disabled={isLoading || !question.trim()}
            >
              Send
            </Button>

            <IconButton
              color={isRecording ? "error" : "primary"}
              onClick={recordAndSend}
              disabled={isLoading}
              sx={{ mr: 1 }}
            >
              <Mic />
            </IconButton>
          </>
        )}

        {/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ summary Î™®Îìú ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}
        {inputMode === "summary" && (
          <>
            <Button
              variant="outlined"
              component="label"
              size="small"
              disabled={isLoading}
            >
              ÌååÏùº
              <input
                hidden
                type="file"
                accept=".pdf,.txt"
                onChange={e => setUploadFile(e.target.files?.[0] || null)}
              />
            </Button>

            <Typography
              variant="body2"
              sx={{
                flex: 1,
                maxWidth: 240,
                whiteSpace: "nowrap",
                overflow: "hidden",
                textOverflow: "ellipsis",
              }}
            >
              {uploadFile?.name || "ÏÑ†ÌÉùÎêú ÌååÏùº ÏóÜÏùå"}
            </Typography>

            <Button
              variant="contained"
              onClick={summarize}
              disabled={!uploadFile || isLoading}
            >
              ÏöîÏïΩ
            </Button>
          </>
        )}
        </Box>
      </Box>

      {/* Îπ†Î•∏ ÏùºÏ†ï Dialog */}
      <Dialog open={openQuick} onClose={()=>setOpenQuick(false)}>
        <DialogTitle>Îπ†Î•∏ ÏùºÏ†ï Ï∂îÍ∞Ä</DialogTitle>
        <DialogContent sx={{ display:"flex", flexDirection:"column", gap:2, mt:1 }}>
          <TextField label="Ï†úÎ™©" value={quickTitle} onChange={e=>setQuickTitle(e.target.value)} />
          <TextField type="date" label="ÎÇ†Ïßú" InputLabelProps={{ shrink:true }} value={quickDate} onChange={e=>setQuickDate(e.target.value)} />
        </DialogContent>
        <DialogActions>
          <Button onClick={()=>setOpenQuick(false)}>Ï∑®ÏÜå</Button>
          <Button variant="contained" onClick={async()=>{ await quickSave(); }} disabled={!quickTitle.trim()}>Ï†ÄÏû•</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={!!editCid} onClose={()=>setEditCid(null)}>           {/* ‚òÖ NEW */}
        <DialogTitle>ÎåÄÌôî Ï†úÎ™© Î≥ÄÍ≤Ω</DialogTitle>
        <DialogContent>
          <TextField
            fullWidth autoFocus
            value={editTitle}
            onChange={e=>setEditTitle(e.target.value)}
            label="ÏÉà Ï†úÎ™©"
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={()=>setEditCid(null)}>Ï∑®ÏÜå</Button>
          <Button variant="contained" disabled={!editTitle.trim()}
            onClick={async()=>{
              if(editCid){ await renameConversation(editCid, editTitle.trim()); }
              setEditCid(null);
            }}
          >Ï†ÄÏû•</Button>
        </DialogActions>
      </Dialog>

      {/* ‚îÄ‚îÄ‚îÄ ÎÖπÏùå Ï§ë ÏïàÎÇ¥ ‚îÄ‚îÄ‚îÄ */}
      <Dialog open={isRecording} PaperProps={{ sx:{ textAlign:"center", p:3 } }}>
        <DialogTitle sx={{ pb:1 }}>üé§ ÏùåÏÑ± Î™ÖÎ†πÏùÑ ÎßêÏîÄÌïòÏÑ∏Ïöî</DialogTitle>
        <DialogContent sx={{ display:"flex", flexDirection:"column", alignItems:"center", gap:2 }}>
          <Typography>ÎÇ®ÏùÄ ÏãúÍ∞Ñ: <b>{recordLeft}</b>Ï¥à</Typography>
          <LinearProgress
            variant="determinate"
            value={(5 - recordLeft) * 20}    // 0‚Ä•100 %
            sx={{ width:200, height:8, borderRadius:4 }}
          />
        </DialogContent>
      </Dialog>

      {/* ÌîÑÎ°úÌïÑ ÏûÖÎ†• Îã§Ïù¥ÏñºÎ°úÍ∑∏ */}
      <ProfilingDialog
        open={openProfileDlg}
        onClose={()=>setOpenProfileDlg(false)}
        onSaved={()=>{ setProfileExists(true); setOpenProfileDlg(false); }}
      />

      <MuiDialog
        open={!!fullImgUrl}
        onClose={()=>{
          if(fullImgUrl){
            URL.revokeObjectURL(fullImgUrl);     // Î©îÎ™®Î¶¨ Ìï¥Ï†ú
            setFullImgUrl(null);
          }
        }}
        PaperProps={{ sx:{ p:0, background:"transparent" } }}
      >
        {fullImgUrl && (
          <img
            src={fullImgUrl}
            style={{
              width:512, height:512,            // Í≥†Ï†ï 512 √ó 512
              objectFit:"contain",
              display:"block"
            }}
          />
        )}
      </MuiDialog>
    </Box>
  );
}
